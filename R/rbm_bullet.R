# WARNING - Generated by {fusen} from dev/function_documentation.Rmd: do not edit by hand

#' @title Generate a bullet chart for quick quality assurance
#' @description  
#'  In a Bullet Graph, the main data value is encoded by length with the bar in the 
#'  centre of the chart, which is known as the Feature Measure. The line marker that 
#'  runs perpendicular to the orientation of the graph is known as the Comparative 
#'  Measure and is used as a target marker to compare against the Feature Measure 
#'  value. So if the main bar has passed the position of Comparative Measure, you 
#'  know you've hit your goal.
#'  
#'  See https://datavizcatalogue.com/methods/bullet_graph.html

#'  The segmented coloured bars behind the Feature Measure are used to display 
#'  qualitative range scores. Each colour shade (the three shades of grey in the
#'  example above) are used to assign a performance range rating. So for example,
#'  poor, average and great. When using Bullet Graphs, it's ideal to keep the 
#'  maximum number of performance ranges to five. 
#'
#' @param data table resulting from  prepare_qa_data()
#' @param thisind which indicator to chart
#'
#' @importFrom unhcrthemes theme_unhcr
#'
#' @return list with plot and QA data
#' 
#' @export
#'
#' @examples
#'
#' data <- prepare_qa_data(activityInfoTable= "cdn6y40lm87wi522")
#'
#' thisind <- "OA2-2.1"
#' rbm_bullet(data, thisind)[["plot"]]
#'
#' thisind <- "OA2-2.2"
#' rbm_bullet(data, thisind)[["plot"]]
rbm_bullet <- function(data, thisind){
  # thisind <-  "OA1-1.2"
  #names(data)
  thisdata1 <- data |>
             dplyr::filter(Ind_id == thisind) |>
             # dplyr::select(Operation, country,means_verification_indicator, means_verification_population_type, population_label, 
             #               means_verification_data_source, means_verification_additional_data_sources, data_sources_comment,
             #               baseline_2023_percent,
             #               actual_2023, target_2023, op_target_2023, ol_target_2023, 
             #               Show_As, Reverse, area, means_verification_results_level,
             #               threshold_red, threshold_orange, threshold_green, Reverse, standard_direction,
             #               disag_PopulationType, disag_Age, disag_Gender, disag_Disability, 
             #               disag_Origin, disag_Nation)  |>
            dplyr::mutate(country = stringr::str_replace(country, " \\(Bolivarian Republic of\\)", "")) |>
            dplyr::distinct() |>
             dplyr::mutate(means_verification_additional_data_sources = stringr::str_replace_all(means_verification_additional_data_sources,
                                                                             "https://", " " ) ) |>
            dplyr::rename(target = target_2023, 
                          baseline = baseline_2023_percent, 
                          actual = actual_2023 ) |>  
            dplyr::mutate(means_verification_additional_data_sources = substr(means_verification_additional_data_sources, 0 , 50)) |>
            tidyr::unite(col =  "data_info", 
             # all_of( c("means_verification_data_source", "means_verification_additional_data_sources") ), 
              all_of( c("means_verification_data_source" ) ), 
                      na.rm = TRUE, 
                      sep = "<br> ",
                 remove = FALSE) |>
            ## Trying to sanitize to get rid of..
            ## Error: gridtext has encountered a tag that isn't supported yet: <a>
            # Only a very limited number of tags are currently supported.
            
            dplyr::mutate(data_info = stringr::str_replace_all(data_info, "https://", " " ) ) |>
            dplyr::mutate(data_info = stringr::str_replace_all(data_info, "www.", " " ) ) |>
    
            dplyr::mutate( group = as.character(glue::glue("{country}/{means_verification_population_type}") ) ) |>
            dplyr::mutate( operation = as.character(
             # glue::glue("<b>{country}/{means_verification_population_type}</b><br> <i> {data_info}</i>") ) ) |>
              glue::glue("<span style='font-size:10pt'><b>{country}/{means_verification_population_type}</b></span><span style='font-size:8pt'><br> <i> {data_info}</i></span>") ) ) |>
            #dplyr::arrange(desc(actual))
            dplyr::group_by(country) |>
            dplyr::arrange(desc( actual), .by_group=TRUE ) |> 
            dplyr::ungroup(country) 
  
    ## We keep only when there's value for plotting!
    thisdata <- thisdata1   |>
            dplyr::filter( !(is.na(actual))) 
    #thisdata$operation
    
    nline <- nrow(thisdata)
    
    level <- thisdata |>
              dplyr::distinct(means_verification_results_level) |>
              dplyr::pull()
    
    indname <- thisdata |>
              dplyr::distinct(means_verification_indicator) |>
              dplyr::pull()
    standard_direction <- thisdata |>
              dplyr::distinct(standard_direction) |>
              dplyr::pull()
    Reverse <- thisdata |>
              dplyr::distinct(Reverse) |>
              dplyr::pull()
    Show_As <- thisdata |>
              dplyr::distinct(Show_As) |>
              dplyr::pull()
    area <- thisdata |>
              dplyr::distinct(dplyr::coalesce(means_verification_outcome_area,means_verification_impact_area)) |>
              dplyr::pull()
    ## levels(as.factor(data$means_verification_results_level))
    means_verification_results_level <- thisdata |>
              dplyr::distinct(means_verification_results_level) |>
              dplyr::pull()

    
## case there's no data at all 

if( nrow(thisdata) == 0) {
  info <-  paste0("There\'s no recorded value \n",
                  "for ", level, " indicator: \n",
                  thisind)
  p <- ggplot() +  annotate("text",  x = 1, y = 1, size = 12,  
                            label = info ) +  theme_void() 
  
  } else if(nrow(thisdata)> 0) {
      ## and now the plot
    p <- ggplot(  data = thisdata ) +
      coord_flip() 
    
    ## Background with color band! 
    if( standard_direction == "more_or_equal") {
      maxgreen <- max(thisdata$threshold_green)
      maxorange <- max(thisdata$threshold_orange)
      maxred <- max(thisdata$threshold_red)
      yaxistext <- paste0("\n (as ", Show_As, ") Actual value = horizontal blue line. \n Baseline = black vertical line | Target = vertical grey line")
      p <- p +
        geom_col( aes(x = reorder(operation, actual) , y = threshold_green),
                  fill = "#069C56", width = 0.6, alpha = 0.4  ) +
        geom_col( aes(x = reorder(operation, actual), y = threshold_orange),
                  fill = "#FF980E", width = 0.6,  alpha = 0.4 ) +
        geom_col(  aes(x = reorder(operation, actual), y = threshold_red),
                   fill = "#D3212C", width = 0.6, alpha = 0.4 )
    }  else if ( standard_direction == "less_or_equal") { 
      
      maxgreen <- max(thisdata$threshold_green)
      maxorange <- max(thisdata$threshold_orange)
      maxred <- max(thisdata$threshold_red)
      yaxistext <- paste0("\n (as ", Show_As, ") Actual value = horizontal blue line. \n Baseline = black vertical line | Target = vertical grey line")
      p <- p   +
        geom_col(  aes(x = reorder(operation, actual), y = threshold_red),
                   fill = "#D3212C", width = 0.6, alpha = 0.4 )+
        geom_col( aes(x = reorder(operation, actual), y = threshold_orange),
                  fill = "#FF980E", width = 0.6,  alpha = 0.4 )+
        geom_col( aes(x = reorder(operation, actual) , y = threshold_green),
                  fill = "#069C56", width = 0.6, alpha = 0.4  )
    }
    
    p <- p  +
      geom_errorbar(  aes(x = reorder(operation, actual), ymin = baseline, ymax = baseline),
                      color = "black",  width = 0.45,  size = 1) 
    
    ## Add the target and change the color based on the context
    if( means_verification_results_level == "Outcome" & standard_direction == "No_standard") { 
      p <- p  +
        geom_errorbar(  aes(x = reorder(operation, actual), ymin = target, ymax = target),
                        color = "grey50",  width = 0.45, size = 1  ) 
    }   else  if ( means_verification_results_level == "Outcome" & standard_direction != "No_standard"){  
      p <- p  +
        geom_errorbar(  aes(x = reorder(operation, actual), ymin = target, ymax = target),
                        color = "white",  width = 0.45, size = 1  )    }     else { }
    
    p <- p  +
      geom_col(   aes(x = reorder(operation, actual), y = actual),
                  fill = "#0072BC",  color = NA,  width = 0.3 ) + 
      # geom_text(aes(x = reorder(operation, actual), y = actual,
      #               label = round(actual, 1)),
      #           hjust = 1.5, size = 3,color = "white")  
        
      ## Position label differently in the bar in white - outside bar in black
      ggplot2::geom_text(
          data = subset( thisdata, actual < max(actual) / 1.5),
          ggplot2::aes( x = reorder(operation, actual), y = actual,
                    label = round(actual, 1) ),
          hjust = -0.1 ,  vjust = 0.5, colour = "black", size = 3    ) +
      ggplot2::geom_text(
          data = subset( thisdata, actual >= max(actual) / 1.5),
          ggplot2::aes( x = reorder(operation, actual), y = actual,
                    label = round(actual, 1)),
          hjust = 1.1 , vjust = 0.5, colour = "white",  size = 3)  
    
    
    
    ## Change scale based on unit!
    if( Show_As == "Percent") {
      p <- p +
        # scale_y_continuous( label = scales::label_percent(accuracy = 0,
        #                                 suffix = "%") ) 
        scale_y_continuous( label =  scales::label_number(accuracy = 1,  
                                                          scale_cut = scales::cut_short_scale()) )
    } else {
      p <- p +
        scale_y_continuous( label =  scales::label_number(accuracy = 1,  
                                                          scale_cut = scales::cut_short_scale()) )
    }  
    
    ## Build the axis explanation -- accounting for the unit - 
    # and for the existence of a target in case the indicator is an ooutcome   
    if( means_verification_results_level == "Outcome" & standard_direction != "No_standard") {
      yaxistext <- paste0("\n (as ",
                          Show_As,
                          ") Actual value = horizontal blue line. \n Baseline = black vertical line | Target = vertical white line") 
      
    } else if(means_verification_results_level == "Outcome" & standard_direction == "No_standard") {
      
      yaxistext <- paste0("\n (as ",
                          Show_As,
                          ") Actual value = horizontal blue line. \n Baseline = black vertical line | Target = vertical grey line")
      
    } else if (means_verification_results_level == "Impact" ) {
      
      yaxistext <- paste0("\n (as ",
                          Show_As,
                          ") Actual value = horizontal blue line. \n Baseline = black vertical line")
      
    } 
    
    p <- p +
      unhcrthemes::theme_unhcr(font_size = 12, 
                              # rel_small = 6/9,
                               grid = "X", 
                               axis = "y") +
      theme(  axis.text.y = ggtext::element_markdown()) +
      labs( x = "", y =  yaxistext ,
            title = stringr::str_wrap( paste0(level, " Indicator: ", indname) , 60),
            subtitle = stringr::str_wrap( paste0( area, 
                                                  " - Regional Comparison Americas | 2023 Quality Assurance" ) ,
                                          80),
            caption = "Source: UNHCR RBM / Compass (provisional)") }
    
    
  ### Output table --   
  if(nline > 0) {
  ## Format number based on show as
  
    if( Show_As == "Percent" & means_verification_results_level == "Outcome"){
    thisdataout <- thisdata1 |> 
      dplyr::select( group, baseline, actual,  target, QA_logical, actual_2023_data_limitations) |>
      dplyr::rename( "data_limitation" = "actual_2023_data_limitations") |>
      dplyr::mutate( 
        actual = round(actual, 1),
        baseline = round(baseline, 1),
        target = round(target, 1) ) |>
    ## Replace all NA by (-) 
    dplyr::mutate(across(everything(), as.character)) |>
    dplyr::mutate(across(everything(),   ~tidyr::replace_na(.x, "-")   ))  
      
    
  }   else if( Show_As == "Percent" & means_verification_results_level == "Impact"){
    thisdataout <- thisdata1 |> 
      dplyr::select( group, baseline , actual,  QA_logical, actual_2023_data_limitations) |>
      dplyr::rename( "data_limitation" = "actual_2023_data_limitations") |>
      dplyr::mutate( 
        actual = round(actual, 1),
        baseline = round(baseline, 1)  ) |>
    ## Replace all NA by (-) 
    dplyr::mutate(across(everything(), as.character)) |>
    dplyr::mutate(across(everything(),   ~tidyr::replace_na(.x, "-")   ))  
      
  }   else if( Show_As != "Percent" & means_verification_results_level == "Impact"){
    thisdataout <- thisdata1 |> 
      dplyr::select( group, baseline,actual,  QA_logical , actual_2023_data_limitations) |>
      dplyr::rename( "data_limitation" = "actual_2023_data_limitations") |>
      dplyr::mutate( 
        actual = round(actual, 1),
        baseline = round(baseline, 1) ) |>
    ## Replace all NA by (-) 
    dplyr::mutate(across(everything(), as.character)) |>
    dplyr::mutate(across(everything(),   ~tidyr::replace_na(.x, "-")   ))  
      
  } else if( Show_As != "Percent" & means_verification_results_level == "Outcome"){
    thisdataout <- thisdata1 |> 
      dplyr::select( group, baseline, actual, target, QA_logical, actual_2023_data_limitations) |>
      dplyr::rename( "data_limitation" = "actual_2023_data_limitations") |>
      dplyr::mutate( 
        actual = as.integer(actual),
        baseline = as.integer(baseline),
        target = as.integer(target)) |>
    ## Replace all NA by (-) 
    dplyr::mutate(across(everything(), as.character)) |>
    dplyr::mutate(across(everything(),   ~tidyr::replace_na(.x, "-")   ))  
      
  }
  } else { thisdataout <- ""}
  ## Validation comment
  comment <- ""       
         
         
         

  out <- list( data = thisdataout ,
               plot = p,
               comment = comment)

  return(out)
}

