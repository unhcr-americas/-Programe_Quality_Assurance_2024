---
title: "Function documentation"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

<!--
 For each fo the function you need, add FUSEN chunk through the Rstudio add-in " add {fusen} chunks"
 -->
 
# prepare_qa_data
    
```{r function-prepare_qa_data}
#' prepare_qa_data
#' 
#' Note that this function is specific to a specific DB schema -
#' the form to query as well as the columns variable name are hard coded and 
#' would need to be adjusted if the DB change
#' 
#' 
#' Implemented QA automatic Check
#'  Missing M&E Data sources
#'  Missing M&E Activity
#'  Missing Baseline
#'  Missing Baseline Numerator
#'  Missing Baseline Denominator
#'  Missing Actual
#'  Missing Actual Numerator
#'  Missing Actual Denominator
#'  Incorrect Baseline (i.e. >100%)
#'  Incorrect Actual (i.e. >100%)
#'  Baseline Higher (Lower) than Actual
#'  Significant Variance between Baseline and Actual (+/- 2*Baseline)
#'  Missing Data Limitation for Baseline
#'  Missing Data Limitation for Actual
#' 
#' 
#' Note also that the function is based on a token stored as an environment 
#' variable
#' 
#'  Credentials set up as environment variables - 
#'  
#'  # token <- "activityinfotoken.."
#'  # print(Sys.setenv(ACTIVITYINFOTOKEN = token))   
#'  # Sys.getenv("ACTIVITYINFOTOKEN")
#'  # rm(token)
#' @importFrom activityinfo activityInfoToken queryTable
#' @importFrom janitor clean_names
#' @importFrom jsonlite fromJSON

#' @param activityInfoTable activityInfo link to the db where indicators got reported
#' 
#' @return frame with the content of the activity info DB plus indicator reference
#'         and applied QA
#' 
#' @export
prepare_qa_data <- function(activityInfoTable ){
  
 # Connect to ActivityInfo using Token  
 activityinfo::activityInfoToken(Sys.getenv("ACTIVITYINFOTOKEN"),
                                prompt = FALSE)
  
  df  <- activityinfo::queryTable( form= activityInfoTable) |>
          janitor::clean_names()
  
  

  #Plan  <- activityinfo::queryTable(  activityInfoPlan,  "Operation" =  activityInfoPlan) |>
  # Plan  <- activityinfo::queryTable("caqxz3lrqv8wig3",  "Operation" = "clsk9d2lrqv90su4") |>
  #         janitor::clean_names()
  # #Country  <- activityinfo::queryTable(   activityInfoCountry,  
  # Country  <- activityinfo::queryTable( "cwpgxrfllcr4wv66", 
  #             "Operation" = "cri1wrylrqvanj2j.clsk9d2lrqv90su4",
  #             "Country" = "c3gm12qlrqv4kih12") |>
  #                     janitor::clean_names()
   
  # plan <- readr::read_csv(system.file("M_E_Plan1.csv", 
  #               package = "ProgQA"))
  # country <- readr::read_csv(system.file("M_E_Plan.csv", 
  #               package = "ProgQA"))
  
  #plan <- jsonlite::fromJSON(system.file("caqxz3lrqv8wig3.json", package = "ProgQA"))
  
  ### Workaround... not sure the API does not work... downloaded the JSOn file 
  ## as it is the only one with the ID
  country <- jsonlite::fromJSON(system.file("cwpgxrfllcr4wv66.json", package = "ProgQA"))|>
          janitor::clean_names()
  
  
  # names(df)
  
#    [1] "x_id"                                        
#  [2] "x_last_edit_time"                            
#  [3] "means_verification_id"                       
#  [4] "means_verification_operation_country_id"     
#  [5] "means_verification_year"                     
#  [6] "means_verification_results_level"            
#  [7] "means_verification_impact_area"              
#  [8] "means_verification_outcome_area"             
#  [9] "means_verification_indicator_code"           
# [10] "means_verification_indicator"                
# [11] "means_verification_population_type"          
# [12] "means_verification_disaggregation"           
# [13] "means_verification_data_source"              
# [14] "means_verification_additional_data_sources"  
# [15] "means_verification_data_source_comments"     
# [16] "means_verification_mn_e_activity"            
# [17] "means_verification_mn_e_activity_comments"   
# [18] "means_verification_data_collection_frequency"
# [19] "means_verification_responsibility_internal"  
# [20] "means_verification_responsibility_external"  
# [21] "means_verification_target2023"               
# [22] "means_verification_target2024"               
# [23] "means_verification_target2025"               
# [24] "means_verification_target2026"               
# [25] "means_verification_actual_num_2022"          
# [26] "means_verification_actual_den_2022"          
# [27] "means_verification_actual_2022"              
# [28] "means_verification_baseline_2023_rounded"    
# [29] "disaggregation"                              
# [30] "data_collection_frequency"                   
# [31] "me_activity_comments"                        
# [32] "additional_data_sources"                     
# [33] "data_source_comments"                        
# [34] "same_source"                                 
# [35] "data_source_revised"                         
# [36] "data_comments_revised"                       
# [37] "data_source_link"                            
# [38] "target_2023"                                 
# [39] "use_actuals"                                 
# [40] "baseline_change_comm"                        
# [41] "baseline_2023_numerator"                     
# [42] "baseline_2023_denominator"                   
# [43] "baseline_2023_percent"                       
# [44] "baseline_2023_data_limitations"              
# [45] "actual_2023_numerator"                       
# [46] "actual_2023_denominator"                     
# [47] "actual_2023_percent"                         
# [48] "actual_2023_data_limitations"                
# [49] "please_check_value_over_100"                 
# [50] "please_check_value_not_between_1_3"          
# [51] "the_actual_value_is_higher_than_the_baseline"
# [52] "the_actual_value_is_lower_than_the_baseline" 
# [53] "the_actual_value_is_higher_than_the_target"  
# [54] "the_actual_value_is_lower_than_the_target"  
  
  df1 <- df |>
    dplyr::left_join(country, by = c( "means_verification_operation_country_id" = "id" ) ) |>
    dplyr::left_join(ProgQA::mapping_indicator , by = c("means_verification_indicator_code" = "Indicator_Code") )  |>
    
    ## let's create the actual indicator value - independetly of wether is it's a percent or not..
    dplyr::mutate( actual_2023 = dplyr::if_else( Show_As == "Percent" ,
                                                 actual_2023_percent, 
                                                 actual_2023_numerator),
                   baseline_2023 = dplyr::if_else( Show_As == "Percent" ,
                                                 baseline_2023_percent, 
                                                 baseline_2023_numerator) ) |>
    
    
      # __Comp1.__ All mandatory core impact indicators and core outcome indicators from relevant outcome areas have been selected for all relevant population groups
      dplyr::mutate(Comp1_1 = dplyr::if_else( is.na(means_verification_population_type), "Missing Population Type", NA ) #,
                    # Comp1_2 = dplyr::if_else( !( is.na(means_verification_population_type)) & 
                    #                             stringr::str_detect(means_verification_population_type ,popmatch),
                    #                           "Population Type not matching indicator", NA ) 
                    ) |>
        
        # __Comp2.__ Values for baselines, targets and actuals have been entered for all selected indicators and all relevant population groups
        dplyr::mutate(Comp2_1 = dplyr::if_else( is.na(actual_2023), "Missing Actual", NA ),
                      Comp2_2 = dplyr::if_else( is.na(baseline_2023_percent), "Missing Baseline", NA ),
                      Comp2_3 = dplyr::if_else( is.na(target_2023) & means_verification_results_level == "Outcome", "Missing Target", NA ) ) |>
        
        # __Comp3.__ Appropriate means of verification have been selected - aka data source is not empty
        dplyr::mutate(Comp3 = dplyr::if_else( is.na(means_verification_data_source), "Missing Data Source", NA ) ) |>
        
        # __Comp4.__ Data limitations have been recorded for each indicator, as applicable - when no data is provided, while that indicator was selected for that population group 
        dplyr::mutate(Comp4 = dplyr::if_else( is.na(actual_2023)   & 
                                                is.na(actual_2023_data_limitations) ,
                                              "Missing Data limitations while there's no data", NA ) ) |> 
        
        # __Acc1.__ Percentage indicators are correctly calculated, when both numerator and baseline
        dplyr::mutate(Acc1_1 = dplyr::if_else( Show_As == "Percent"   & 
                                                 is.na(actual_2023_numerator) ,
                                               "Numerator for Actual is missing", NA ),
                      Acc1_2 = dplyr::if_else( Show_As == "Percent"   & 
                                                 is.na(actual_2023_denominator) ,
                                               "Denominator for Actual is missing", NA ),
                      Acc1_3 = dplyr::if_else( Show_As == "Percent"   & 
                                                 !( is.na(actual_2023_denominator)& 
                                                      is.na(actual_2023_numerator) & 
                                                      is.na(actual_2023)) &
                                                 round(actual_2023,0) != round((actual_2023_numerator/actual_2023_denominator *100),0),
                                               "Percentage Calculation for Actual is not correct", NA ),
                      Acc1_4 = dplyr::if_else( Show_As == "Percent"   & 
                                                 is.na(baseline_2023_numerator) ,
                                               "Numerator for baseline is missing", NA ),
                      Acc1_5 = dplyr::if_else( Show_As == "Percent"   & 
                                                 is.na(baseline_2023_denominator) ,
                                               "Denominator for baseline is missing", NA ),
                      Acc1_6 = dplyr::if_else( Show_As == "Percent"   & 
                                                 !( is.na(baseline_2023_denominator)& 
                                                      is.na(baseline_2023_numerator) & 
                                                      is.na(baseline_2023_percent)) &
                                                 round(baseline_2023_percent,0) != round((baseline_2023_numerator/baseline_2023_denominator *100),0),
                                               "Percentage Calculation for baseline is not correct", NA ) ) |> 
        
        # __Acc2.__ Appropriate scales are used for text indicators. If a text unit, should be between 1 & 3
        dplyr::mutate(Acc2_1 = dplyr::if_else( Show_As == "Text"   &  
                                                 !( is.na(actual_2023)) &
                                                 !( actual_2023 %in% c(1,2,3)) ,
                                               "Appropriate scales is not used for actual text indicators", NA ),
                      Acc2_2 = dplyr::if_else( Show_As == "Text"   & 
                                                 !( is.na(baseline_2023_percent)) &
                                                 !( baseline_2023_percent %in% c(1,2,3)) ,
                                               "Appropriate scales is not used for baseline text indicators", NA ) ) |> 
        
        # __Acc3.__ Units of measurements are consistently used for baselines, actuals and targets. , if pecent between 0 & 100, if a number no denominator 
        dplyr::mutate(Acc3_1 = dplyr::if_else( Show_As == "Percent"   &  
                                                 !( is.na(actual_2023)) &
                                                 ( actual_2023 < 0 | actual_2023 >100) ,
                                               "Appropriate scales is not used for actual percent indicators", NA ),
                      Acc3_2 = dplyr::if_else( Show_As == "Percent"   & 
                                                 !( is.na(baseline_2023_percent)) &
                                                 ( baseline_2023_percent <0 | baseline_2023_percent >100) ,
                                               "Appropriate scales is not used for baseline percent indicators", NA ) ) |> 
        
        # __Acc4.__ The approach to missing values is correct, i.e., the use of “0” vs NA
        
        # __Acc5.__ The relationship between baseline and target data is logical, e.g., targets are equal to or higher than the baselines
        dplyr::mutate(Acc5_1 = dplyr::if_else( standard_direction == "more_or_equal"   &  
                                                 means_verification_results_level == "Outcome" &
                                                 !( is.na(baseline_2023_percent)) & 
                                                 !( is.na(target_2023)) &
                                                 target_2023 < baseline_2023_percent ,
                                               "Target value is below the baseline", NA ) ,
                      Acc5_2 = dplyr::if_else( standard_direction == "less_or_equal"   &  
                                                 means_verification_results_level == "Outcome" & 
                                                 !( is.na(baseline_2023_percent)) & 
                                                 !( is.na(target_2023)) &
                                                 target_2023 > baseline_2023_percent ,
                                               "Target value is above the baseline", NA ) ,
                      Acc5_3 = dplyr::if_else( standard_direction == "more_or_equal"   &  
                                                 means_verification_results_level == "Outcome" & 
                                                 !( is.na(threshold_green)) & 
                                                 !( is.na(target_2023)) &
                                                 target_2023 < threshold_green ,
                                               "Target value is below acceptable standard", NA ) ,
                      Acc5_4 = dplyr::if_else( standard_direction == "less_or_equal"   &  
                                                 means_verification_results_level == "Outcome" & 
                                                 !( is.na(threshold_green)) & 
                                                 !( is.na(target_2023)) &
                                                 target_2023 > threshold_green ,
                                               "Target value is above acceptable standard", NA )  )   |>
        
        # __Cons1.__ Detect strange issue
        dplyr::mutate(Cons1_1 = dplyr::if_else( Show_As == "Percent"    &  
                                                  means_verification_results_level == "Outcome" &
                                                  !( is.na(baseline_2023_percent)) & 
                                                  !( is.na(target_2023)) &
                                                  abs(target_2023 - baseline_2023_percent) > 40 ,
                                                "More than 40% difference between Target and Baseline", NA ) ,
                      Cons1_2 = dplyr::if_else( Show_As == "Percent"  & 
                                                  !( is.na(baseline_2023_percent)) & 
                                                  !( is.na(actual_2023)) &
                                                  abs(actual_2023 - baseline_2023_percent) > 40 ,
                                                "More than 20% difference between Actual and Baseline", NA ) #,
                      # Cons1_3 = dplyr::if_else( Show_As == "Percent"   & 
                      #                             !( is.na(baseline_2023_denominator) ) &
                      #                           #  !( is.na(asr2022)) &
                      #                             baseline_2023_denominator > asr2022 ,
                      #                           "Baseline Denominator is superior to last public release of ASR data", NA ) ,
                      # Cons1_4 = dplyr::if_else( Show_As == "Percent"   & 
                      #                             !( is.na(actual_2023_denominator) ) &
                      #                           #  !( is.na(asr2022)) &
                      #                             actual_2023_denominator > asr2022 ,
                      #                           "Actual Denominator is superior to last public release of ASR data", NA ) 
                      )   |>
        
        
        ## Summary QA
        tidyr::unite(col =  "QA_logical", 
                     all_of( c("Comp1_1",#"Comp1_2",
                               "Comp2_1","Comp2_2","Comp2_3", 
                               "Comp3",
                               "Comp4",
                               "Acc1_1","Acc1_2","Acc1_3",
                               "Acc1_4","Acc1_5","Acc1_6",
                               "Acc2_1","Acc2_2",  
                               "Acc3_1","Acc3_2", 
                               "Acc5_1","Acc5_2","Acc5_3","Acc5_4", 
                               "Cons1_1","Cons1_2" #,"Cons1_3","Cons1_4"
                               ) ), 
                     na.rm = TRUE, 
                     sep = " - ",
                     remove = FALSE) 
  
  return(df1)
    
}
```
  
```{r example-prepare_qa_data}
#prepare_qa_data(activityInfoTable= "cdn6y40lm87wi522", activityInfoPlan ="caqxz3lrqv8wig3", activityInfoCountry="cwpgxrfllcr4wv66")
data <- prepare_qa_data(activityInfoTable= "cdn6y40lm87wi522")
```
  
```{r tests-prepare_qa_data}
test_that("prepare_qa_data works", {
  expect_true(inherits(prepare_qa_data, "function")) 
})
```
  
# summary_qa_chart
    
```{r function-summary_qa_chart}
#' summary_qa_chart
#' 
#' Display a summary QA charts based on data
#' @param data table resulting from  prepare_qa_data()
#' 
#' @return ggplot2 chart
#' 
#' @import ggplot2
#' @importFrom unhcrthemes theme_unhcr
#' 
#' @export
summary_qa_chart <- function(data ){
  
  
  
    summary1  <- rbind( 
              round(prop.table(table( data$operation_mco, data$Comp1_1, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              # round(prop.table(table( data$operation_mco, data$Comp1_2, useNA = "ifany"), margin=1)* 100 , 1) |> 
              #   as.data.frame()|>
              #   dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Comp2_1, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Comp2_2, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Comp2_3, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              # round(prop.table(table( data$operation_mco, data$Comp3, useNA = "ifany"), margin=1)* 100 , 1) |> 
              #   as.data.frame()|>
              #   dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Comp4, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Acc1_1, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Acc1_2, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              # round(prop.table(table( data$operation_mco, data$Acc1_3, useNA = "ifany"), margin=1)* 100 , 1) |> 
              #   as.data.frame()|>
              #   dplyr::filter( !(is.na(Var2))),
              # round(prop.table(table( data$operation_mco, data$Acc2_1, useNA = "ifany"), margin=1)* 100 , 1) |> 
              #   as.data.frame()|>
              #   dplyr::filter( !(is.na(Var2))),
              # round(prop.table(table( data$operation_mco, data$Acc2_2, useNA = "ifany"), margin=1)* 100 , 1) |> 
              #   as.data.frame()|>
              #   dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Acc3_1, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Acc3_2, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Acc5_1, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              # round(prop.table(table( data$operation_mco, data$Acc5_2, useNA = "ifany"), margin=1)* 100 , 1) |> 
              #   as.data.frame()|>
              #   dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Acc5_3, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Acc5_4, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Cons1_1, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
              round(prop.table(table( data$operation_mco, data$Cons1_2, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))) #,
              # round(prop.table(table( data$operation_mco, data$Cons1_3, useNA = "ifany"), margin=1)* 100 , 1) |> 
              #   as.data.frame()|>
              #   dplyr::filter( !(is.na(Var2))),
              # round(prop.table(table( data$operation_mco, data$Cons1_4, useNA = "ifany"), margin=1)* 100 , 1) |> 
              #   as.data.frame()|>
              #  dplyr::filter( !(is.na(Var2))) 
              )   |>
  dplyr::filter(Freq > 0) 

p <- summary1 |>
  ggplot2::ggplot(  ggplot2::aes(x = Var1, 
               y = Var2, 
               fill = Freq)) +
  ggplot2::geom_tile(color = "white",
            lwd = 1.5,
            linetype = 1) +
  ggplot2::coord_fixed() +
  ggplot2::geom_text( ggplot2::aes(label = Freq), color = "grey25", size = 2) + 
  ggplot2::scale_y_discrete(labels = scales::label_wrap(50)) + 
  #scale_fill_gradient2(low = "#069C56",    mid = "#FF980E",   high = "#D3212C") +
  ggplot2::scale_fill_gradientn(colors = hcl.colors(7,  palette = "viridis", alpha = 0.6, rev = TRUE)) +
  ggplot2::coord_fixed() +
  unhcrthemes::theme_unhcr(font_size = 13, 
                          # rel_small = 5/9,
                           grid = FALSE, 
                           axis = FALSE) +
  ggplot2::theme(legend.position = "none", 
        axis.text.x = ggplot2::element_text(angle = 45, hjust = 1, vjust = 0.5) ) +
  ggplot2::labs( x = "", y =  "" ,
        title = stringr::str_wrap( paste0("RBM Systematic Quality Check: % of indicator with issues") , 60),
        subtitle = stringr::str_wrap( paste0("Regional Comparison Americas | 2023 Quality Assurance" ) ,
                                      80),
        caption = "Source: UNHCR RBM / Compass ") 

return(p)

    
}
```
  
```{r example-summary_qa_chart, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
data <- prepare_qa_data(activityInfoTable= "cdn6y40lm87wi522")
summary_qa_chart(data)
```
  
```{r tests-summary_qa_chart}
test_that("summary_qa_chart works", {
  expect_true(inherits(summary_qa_chart, "function")) 
})
```
    
# summary_qa_table
    
```{r function-summary_qa_table}
#' summary_qa_table
#' 
#' A summary table of main QA issues
#' @param data table resulting from  prepare_qa_data()
#' 
#' @import flextable
#' 
#' @return
#' 
#' @export
summary_qa_table <- function(data){
  
  ## other summary as per DPSR
summary <- rbind(   
#% of 2023 actuals available
#Comp2_1 = dplyr::if_else( is.na(actual_2023), "Missing Actual", NA ),  
  round(prop.table(table( data$operation_mco, data$Comp2_1, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
# % of baselines available
#Comp2_2 = dplyr::if_else( is.na(baseline_2023_percent), "Missing Baseline", NA ),
              round(prop.table(table( data$operation_mco, data$Comp2_2, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2))),
#% of targets available
#Comp2_3 = dplyr::if_else( is.na(target_2023) & means_verification_results_level == "Outcome", "Missing Target", NA ) ) |>
              round(prop.table(table( data$operation_mco, data$Comp2_3, useNA = "ifany"), margin=1)* 100 , 1) |> 
                as.data.frame()|>
                dplyr::filter( !(is.na(Var2)))  )  |>
          dplyr::mutate(Assess = dplyr::case_when(
             Var2 == "Missing Actual" ~ "% of 2023 actuals available",
             Var2 == "Missing Baseline" ~ "% of baselines available",
             Var2 == "Missing Target" ~ "% of targets available",
              TRUE ~ "" ) ) |>
  dplyr::mutate(Value = round(100 - Freq,1)  ) |>
  dplyr::rename(Plan = Var1 ) |>
  dplyr::select( Plan, Assess, Value) |>
  tidyr::pivot_wider(names_from = Assess, values_from = Value) |>
  dplyr::select("Plan",
                "% of baselines available",
                "% of targets available",	
                "% of 2023 actuals available" ) 
library(tidyverse)
summary2 <- summary |>
  dplyr::ungroup()   |>
 # add_row(year = 'mean', !!! colMeans(.[-1]))  
  dplyr::reframe(Plan = c(as.character(Plan), 'Regional Average'),
            across(where(is.numeric), ~ c(., mean(.)))) |>           
  # Using dplyr functions
  dplyr::mutate_if(is.numeric,
            round,
            digits = 1)
  

ft_2 <- flextable::flextable( summary2 )
ft_2 <- flextable::bg(ft_2, bg = "grey95", part = "header")
ft_2  <- flextable::width(ft_2 , width = 1)
colourer <- scales::col_numeric( palette = "RdYlBu", domain = c(0, 100) )
ft_2 <- flextable::bg(ft_2, j = c(2:4),    bg = colourer, part = "body"  )

## return the results
return(ft_2) 
 
    
}
```
  
```{r example-summary_qa_table, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
data <- prepare_qa_data(activityInfoTable= "cdn6y40lm87wi522")
summary_qa_table(data)
```
  
```{r tests-summary_qa_table}
test_that("summary_qa_table works", {
  expect_true(inherits(summary_qa_table, "function")) 
})
```
    
# rbm_bullet
    
```{r function-rbm_bullet}
#' @title Generate a bullet chart for quick quality assurance
#' @description ## https://datavizcatalogue.com/methods/bullet_graph.html
#'   In a Bullet Graph, the main data value is encoded by length with the bar in the 
#'  centre of the chart, which is known as the Feature Measure. The line marker that 
#'  runs perpendicular to the orientation of the graph is known as the Comparative 
#'  Measure and is used as a target marker to compare against the Feature Measure 
#'  value. So if the main bar has passed the position of Comparative Measure, you 
#'  know you've hit your goal.

#'  The segmented coloured bars behind the Feature Measure are used to display 
#'  qualitative range scores. Each colour shade (the three shades of grey in the
#'  example above) are used to assign a performance range rating. So for example,
#'  poor, average and great. When using Bullet Graphs, it's ideal to keep the 
#'  maximum number of performance ranges to five. 
#'
#' @param data table resulting from  prepare_qa_data()
#' @param thisind which indicator to chart
#'
#' @importFrom unhcrthemes theme_unhcr
#'
#' @return frame with all compass indicators
#' 
#' @export
#'
rbm_bullet <- function(data, thisind){
  # thisind <-  "OA1-1.2"
  #names(data)
  thisdata1 <- data |>
             dplyr::filter(Ind_id == thisind) |>
             # dplyr::select(Operation, country,means_verification_indicator, means_verification_population_type, population_label, 
             #               means_verification_data_source, means_verification_additional_data_sources, data_sources_comment,
             #               baseline_2023_percent,
             #               actual_2023, target_2023, op_target_2023, ol_target_2023, 
             #               Show_As, Reverse, area, means_verification_results_level,
             #               threshold_red, threshold_orange, threshold_green, Reverse, standard_direction,
             #               disag_PopulationType, disag_Age, disag_Gender, disag_Disability, 
             #               disag_Origin, disag_Nation)  |>
            dplyr::mutate(country = stringr::str_replace(country, " \\(Bolivarian Republic of\\)", "")) |>
            dplyr::distinct() |>
             dplyr::mutate(means_verification_additional_data_sources = stringr::str_replace_all(means_verification_additional_data_sources,
                                                                             "https://", " " ) ) |>
            dplyr::rename(target = target_2023, 
                          baseline = baseline_2023_percent, 
                          actual = actual_2023 ) |>  
            dplyr::mutate(means_verification_additional_data_sources = substr(means_verification_additional_data_sources, 0 , 50)) |>
            tidyr::unite(col =  "data_info", 
              all_of( c("means_verification_data_source", "means_verification_additional_data_sources") ), 
                      na.rm = TRUE, 
                      sep = "<br> ",
                 remove = FALSE) |>
            ## Trying to sanitize to get rid of..
            ## Error: gridtext has encountered a tag that isn't supported yet: <a>
            # Only a very limited number of tags are currently supported.
            
            dplyr::mutate(data_info = stringr::str_replace_all(data_info, "https://", " " ) ) |>
            dplyr::mutate(data_info = stringr::str_replace_all(data_info, "www.", " " ) ) |>
    
            dplyr::mutate( group = as.character(glue::glue("{country}/{means_verification_population_type}") ) ) |>
            dplyr::mutate( operation = as.character(
              glue::glue("<b>{country}/{means_verification_population_type}</b><br> <i>({data_info} )</i>") ) ) |>
            #dplyr::arrange(desc(actual))
            dplyr::group_by(country) |>
            dplyr::arrange(desc( actual), .by_group=TRUE ) |> 
            dplyr::ungroup(country) 
  
    ## We keep only when there's value for plotting!
    thisdata <- thisdata1   |>
            dplyr::filter( !(is.na(actual))) 
    #thisdata$operation
    
    nline <- nrow(thisdata)
    indname <- thisdata |>
              dplyr::distinct(means_verification_indicator) |>
              dplyr::pull()
    standard_direction <- thisdata |>
              dplyr::distinct(standard_direction) |>
              dplyr::pull()
    Reverse <- thisdata |>
              dplyr::distinct(Reverse) |>
              dplyr::pull()
    Show_As <- thisdata |>
              dplyr::distinct(Show_As) |>
              dplyr::pull()
    area <- thisdata |>
              dplyr::distinct(dplyr::coalesce(means_verification_outcome_area,means_verification_impact_area)) |>
              dplyr::pull()
    ## levels(as.factor(data$means_verification_results_level))
    means_verification_results_level <- thisdata |>
              dplyr::distinct(means_verification_results_level) |>
              dplyr::pull()

    
## case there's no data at all 

if( nrow(thisdata) == 0) {
  info <-  paste0("There\'s no recorded indicator value \n", thisind)
  p <- ggplot() +  annotate("text",  x = 1, y = 1, size = 12,  
                            label = info ) +  theme_void() 
  
  } else if(nrow(thisdata)> 0) {
      ## and now the plot
    p <- ggplot(  data = thisdata ) +
      coord_flip() 
    
    ## Background with color band! 
    if( standard_direction == "more_or_equal") {
      maxgreen <- max(thisdata$threshold_green)
      maxorange <- max(thisdata$threshold_orange)
      maxred <- max(thisdata$threshold_red)
      yaxistext <- paste0("\n (as ", Show_As, ") Actual value = horizontal blue line. \n Baseline = black vertical line | Target = vertical grey line")
      p <- p +
        geom_col( aes(x = reorder(operation, actual) , y = threshold_green),
                  fill = "#069C56", width = 0.6, alpha = 0.4  ) +
        geom_col( aes(x = reorder(operation, actual), y = threshold_orange),
                  fill = "#FF980E", width = 0.6,  alpha = 0.4 ) +
        geom_col(  aes(x = reorder(operation, actual), y = threshold_red),
                   fill = "#D3212C", width = 0.6, alpha = 0.4 )
    }  else if ( standard_direction == "less_or_equal") { 
      
      maxgreen <- max(thisdata$threshold_green)
      maxorange <- max(thisdata$threshold_orange)
      maxred <- max(thisdata$threshold_red)
      yaxistext <- paste0("\n (as ", Show_As, ") Actual value = horizontal blue line. \n Baseline = black vertical line | Target = vertical grey line")
      p <- p   +
        geom_col(  aes(x = reorder(operation, actual), y = threshold_red),
                   fill = "#D3212C", width = 0.6, alpha = 0.4 )+
        geom_col( aes(x = reorder(operation, actual), y = threshold_orange),
                  fill = "#FF980E", width = 0.6,  alpha = 0.4 )+
        geom_col( aes(x = reorder(operation, actual) , y = threshold_green),
                  fill = "#069C56", width = 0.6, alpha = 0.4  )
    }
    
    p <- p  +
      geom_errorbar(  aes(x = reorder(operation, actual), ymin = baseline, ymax = baseline),
                      color = "black",  width = 0.45,  size = 1) 
    
    ## Add the target and change the color based on the context
    if( means_verification_results_level == "Outcome" & standard_direction == "No_standard") { 
      p <- p  +
        geom_errorbar(  aes(x = reorder(operation, actual), ymin = target, ymax = target),
                        color = "grey50",  width = 0.45, size = 1  ) 
    }   else  if ( means_verification_results_level == "Outcome" & standard_direction != "No_standard"){  
      p <- p  +
        geom_errorbar(  aes(x = reorder(operation, actual), ymin = target, ymax = target),
                        color = "white",  width = 0.45, size = 1  )    }     else { }
    
    p <- p  +
      geom_col(   aes(x = reorder(operation, actual), y = actual),
                  fill = "#0072BC",  color = NA,  width = 0.2 ) + 
      geom_text(aes(x = reorder(operation, actual), y = actual,
                    label = round(actual, 1)),
                hjust = 1.5, size = 3,color = "white") 
    
    ## Change scale based on unit!
    if( Show_As == "Percent") {
      p <- p +
        # scale_y_continuous( label = scales::label_percent(accuracy = 0,
        #                                 suffix = "%") ) 
        scale_y_continuous( label =  scales::label_number(accuracy = 1,  
                                                          scale_cut = scales::cut_short_scale()) )
    } else {
      p <- p +
        scale_y_continuous( label =  scales::label_number(accuracy = 1,  
                                                          scale_cut = scales::cut_short_scale()) )
    }  
    
    ## Build the axis explanation -- accounting for the unit - 
    # and for the existence of a target in case the indicator is an ooutcome   
    if( means_verification_results_level == "Outcome" & standard_direction != "No_standard") {
      yaxistext <- paste0("\n (as ",
                          Show_As,
                          ") Actual value = horizontal blue line. \n Baseline = black vertical line | Target = vertical white line") 
      
    } else if(means_verification_results_level == "Outcome" & standard_direction == "No_standard") {
      
      yaxistext <- paste0("\n (as ",
                          Show_As,
                          ") Actual value = horizontal blue line. \n Baseline = black vertical line | Target = vertical grey line")
      
    } else if (means_verification_results_level == "Impact" ) {
      
      yaxistext <- paste0("\n (as ",
                          Show_As,
                          ") Actual value = horizontal blue line. \n Baseline = black vertical line")
      
    } 
    
    p <- p +
      unhcrthemes::theme_unhcr(font_size = 12, 
                              # rel_small = 6/9,
                               grid = "X", 
                               axis = "y") +
      theme(  axis.text.y = ggtext::element_markdown()) +
      labs( x = "", y =  yaxistext ,
            title = stringr::str_wrap( paste0("RBM Indicator: ", indname) , 60),
            subtitle = stringr::str_wrap( paste0( area, 
                                                  " - Regional Comparison Americas | 2023 Quality Assurance" ) ,
                                          80),
            caption = "Source: UNHCR RBM / Compass ") }
    
    
  ### Output table --   
  if(nline > 0) {
  ## Format number based on show as
  
    if( Show_As == "Percent" & means_verification_results_level == "Outcome"){
    thisdataout <- thisdata1 |> 
      dplyr::select( group, baseline, actual,  target, QA_logical, actual_2023_data_limitations) |>
      dplyr::rename( "data_limitation" = "actual_2023_data_limitations") |>
      dplyr::mutate( 
        actual = round(actual, 1),
        baseline = round(baseline, 1),
        target = round(target, 1) ) |>
    ## Replace all NA by (-) 
    dplyr::mutate(across(everything(), as.character)) |>
    dplyr::mutate(across(everything(),   ~tidyr::replace_na(.x, "-")   ))  
      
    
  }   else if( Show_As == "Percent" & means_verification_results_level == "Impact"){
    thisdataout <- thisdata1 |> 
      dplyr::select( group, baseline , actual,  QA_logical, actual_2023_data_limitations) |>
      dplyr::rename( "data_limitation" = "actual_2023_data_limitations") |>
      dplyr::mutate( 
        actual = round(actual, 1),
        baseline = round(baseline, 1)  ) |>
    ## Replace all NA by (-) 
    dplyr::mutate(across(everything(), as.character)) |>
    dplyr::mutate(across(everything(),   ~tidyr::replace_na(.x, "-")   ))  
      
  }   else if( Show_As != "Percent" & means_verification_results_level == "Impact"){
    thisdataout <- thisdata1 |> 
      dplyr::select( group, baseline,actual,  QA_logical , actual_2023_data_limitations) |>
      dplyr::rename( "data_limitation" = "actual_2023_data_limitations") |>
      dplyr::mutate( 
        actual = round(actual, 1),
        baseline = round(baseline, 1) ) |>
    ## Replace all NA by (-) 
    dplyr::mutate(across(everything(), as.character)) |>
    dplyr::mutate(across(everything(),   ~tidyr::replace_na(.x, "-")   ))  
      
  } else if( Show_As != "Percent" & means_verification_results_level == "Outcome"){
    thisdataout <- thisdata1 |> 
      dplyr::select( group, baseline, actual, target, QA_logical, actual_2023_data_limitations) |>
      dplyr::rename( "data_limitation" = "actual_2023_data_limitations") |>
      dplyr::mutate( 
        actual = as.integer(actual),
        baseline = as.integer(baseline),
        target = as.integer(target)) |>
    ## Replace all NA by (-) 
    dplyr::mutate(across(everything(), as.character)) |>
    dplyr::mutate(across(everything(),   ~tidyr::replace_na(.x, "-")   ))  
      
  }
  } else { thisdataout <- ""}
  ## Validation comment
  comment <- ""       
         
         
         

  out <- list( data = thisdataout ,
               plot = p,
               comment = comment)

  return(out)
}

```
  
```{r example-rbm_bullet, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}

data <- prepare_qa_data(activityInfoTable= "cdn6y40lm87wi522")

thisind <- "OA2-2.1"
rbm_bullet(data, thisind)[["plot"]]

thisind <- "OA2-2.2"
rbm_bullet(data, thisind)[["plot"]]
```
  
```{r tests-rbm_bullet}
test_that("rbm_bullet works", {
  expect_true(inherits(rbm_bullet, "function")) 
})
```
   
   
# incountry_gap
    
```{r function-incountry_gap}
#' @title Generate a bullet chart for in country indicator gap analysis
#' @description This chart is designed to allow for quick gap analysis based on 
#'   all outcome indicators within the same country
#'
#' @param data RBM QA dataset - expect a few pre-defined variables to works well..
#' @param thisoperation_mco which operation plan to chart
#'
#' @importFrom unhcrthemes theme_unhcr
#'
#' @return list with a plot
#' 
#' @export
#'
incountry_gap <- function(data, thisoperation_mco){
    library(tidyverse)
  
  # thiscountry <-  "ECU"
  #names(data)
  thisdata1 <- data |>
      dplyr::filter(operation_mco == thisoperation_mco) |>
      dplyr::mutate(country = stringr::str_replace(country,
                                                   " \\(Bolivarian Republic of\\)", "")) |>
      dplyr::distinct() |>
      dplyr::mutate(means_verification_data_source = stringr::str_replace_all(means_verification_data_source,
                                                                      "https://", " " ) ) |>
      dplyr::rename(target = target_2023, 
                    baseline = baseline_2023_percent, 
                    actual = actual_2023) |>
      
      dplyr::mutate(  actual = as.numeric(actual),
                      target = as.numeric(target),
                      gap_actual_target = - round( (  target - actual) /  target *100  ,2 ),
                      gap_color = dplyr::case_when(
                        gap_actual_target >= 0     ~ "green",
                        gap_actual_target < 0  & gap_actual_target >= -10    ~ "orange",
                        gap_actual_target < -10     ~ "red",  
                                                   TRUE ~ ""),
                      gap_actual_green = - round( ( threshold_green - actual) /  threshold_green *100 ,2 ) )     |>  
      dplyr::mutate(means_verification_data_source = substr(means_verification_data_source, 0 , 50)) |>
      tidyr::unite(col =  "data_info", 
                   all_of( c("means_verification_data_source", "means_verification_additional_data_sources") ), 
                   na.rm = TRUE, 
                   sep = "<br> ",
                   remove = FALSE) |>
      ## Trying to sanitize to get rid of..
      ## Error: gridtext has encountered a tag that isn't supported yet: <a>
      # Only a very limited number of tags are currently supported.
      
      dplyr::mutate(data_info = stringr::str_replace_all(data_info, "https://", " " ) ) |>
      dplyr::mutate(data_info = stringr::str_replace_all(data_info, "www.", " " ) ) |>
      
      dplyr::mutate( group = as.character(glue::glue("{country}/{means_verification_population_type}") ) ) |>
      dplyr::mutate( operation = as.character(glue::glue("{means_verification_outcome_area} - {means_verification_indicator} / {means_verification_population_type}") ) ) |>
      #dplyr::arrange(desc(actual))
      dplyr::group_by(means_verification_indicator) |>
      dplyr::arrange(desc( actual), .by_group=TRUE ) |> 
      dplyr::ungroup(means_verification_indicator) 

## We keep only when there's value for plotting!
thisdataOutcome <- thisdata1   |>
  dplyr::filter( !(is.na(actual))) |>
  dplyr::select(#key, keyctr1, 
                means_verification_results_level, 
                means_verification_indicator, 
                means_verification_outcome_area,  
                means_verification_population_type, 
                actual, 
                target, 
                gap_actual_target,
                gap_color,
                threshold_green, 
                gap_actual_green,
                baseline, 
                standard_direction,
                Reverse, 
                QA_logical, 
                operation_mco,   country,  
                group, operation) |>
  dplyr::filter (! is.na(gap_actual_target)) |>
  dplyr::filter (! is.nan(gap_actual_target)) |>
  dplyr::filter (means_verification_results_level == "Outcome")    

 country <- thisdataOutcome |>
  dplyr::distinct(country) |>
  dplyr::pull()
  ## case there's no data at all
  if( nrow(thisdataOutcome) == 0) {
    info <-  paste0("No gap analysis could be \n produced for \n outcome indicator values \n in ", thiscountry)
    p <- ggplot() +  annotate("text",  x = 1, y = 1, size = 12,
                              label = info ) +  theme_void()
  
  } else if(nrow(thisdataOutcome)> 0) {
  
  ## and now the plot
  p <-  ggplot2::ggplot(  data = thisdataOutcome) +
        ggplot2::coord_flip()  +
    # geom_errorbar(  aes(x = reorder(operation, - gap_actual_target), 
    #                       ymin = gap_actual_green, 
    #                       ymax = gap_actual_green),
    #                   color = "black", 
    #                   #width = 0.45, 
    #                   linewidth = 1)   +
    ggplot2::geom_col(   ggplot2::aes(x = reorder(operation, - gap_actual_target), 
                    y = gap_actual_green  ),
                fill = "grey50",    
                alpha = 0.3,    
                width = 0.9,
                color = NA ) + 
    ggplot2::geom_col(   ggplot2::aes(x = reorder(operation, - gap_actual_target), 
                    y = gap_actual_target,
                    fill = gap_color ),
                #fill = "#0072BC",    
                width = 0.7,
                color = NA ) + 
    ggplot2::scale_fill_manual(values = c( "red" = "#D3212C",    "orange" = "#FF980E",  "green" = "#069C56")) +
    ggplot2::geom_text( ggplot2::aes(x = reorder(operation, - gap_actual_target), 
                   y = gap_actual_target,
                   label = paste(round(gap_actual_target, 1), " %") ),
               #hjust = 1.5, 
               size = 2.5,
               color = "black")  +
    # scale_y_continuous( label = scales::label_percent(accuracy = 0,
    #                                    suffix = "%") ) +
    ggplot2::scale_y_continuous( label =  scales::label_number(accuracy = 1, 
                                                      scale_cut = scales::cut_short_scale(),
                                                      suffix = "%") )+
    ggplot2::scale_x_discrete(labels = function(x) stringr::str_wrap(x, width = 70)) +
  
    unhcrthemes::theme_unhcr(font_size = 11, 
                             #rel_small = 6/9,
                             grid = "X", 
                             axis = "y") +
    ggplot2::theme(  #axis.text.y = ggtext::element_markdown(),
            legend.position = "none")+
    ggplot2::labs( x = "", y = "" ,
          title = stringr::str_wrap( 
            paste0("Outcome RBM Indicators  | 2023 ",country  ) ,  100),
          subtitle = stringr::str_wrap( paste0( 
            "Comparing Gap between Actual value and Target (colored) / Acceptable Threshold (grey)" ) ,
            110),
          caption = stringr::str_wrap( "Source: UNHCR RBM / Compass.  Calculation is performed to measure and compare gap between actual value and target value [(target-actual)/target], as well as value and acceptable threshold  - when relevant - [(threshold_green-actual)/threshold_green]" ,
          110) )  
   }
  out <- list(  plot = p)
  return(out)
}
```
  
```{r example-incountry_gap, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
data <- prepare_qa_data(activityInfoTable= "cdn6y40lm87wi522")
incountry_gap(data, thisoperation_mco = "Brazil ABC" )
```
  
```{r tests-incountry_gap}
test_that("incountry_gap works", {
  expect_true(inherits(incountry_gap, "function")) 
})
```
     

# report_qa
    
```{r function-report_qa}
# usethis::use_rmarkdown_template(
#   template_name = "report_qa",
#   template_dir = NULL,
#   template_description = "Report Quality Assurance",
#   template_create_dir = TRUE
# )
#' Generate a summary word report
#' 
#' @param activityInfo activityInfo link to the db
#' @param folder folder within your project where to put the generated report. 
#'              Folder will be created if it does not exist
#' 
#' @importFrom unhcrdown pptx_slides
#' @importFrom dplyr filter select pull
#' @importFrom rmarkdown render
#' @importFrom here here
#' @importFrom countrycode countrycode
#' @importFrom stringr str_replace_all
#' 
#' @return nothing the file for the report is generated
#' 
#' @export 
#'
report_qa <- function(year = 2023, 
                      activityInfoTable,
                      folder = "Report") {
  
  ## Create the outfolder if it does not exist
  output_dir <- paste0(getwd(),"/",folder)
  if (!dir.exists(output_dir)) {dir.create(output_dir)}
  
  rmarkdown::render(
    system.file("rmarkdown/templates/report_qa/skeleton/skeleton.Rmd", 
                package = "ProgQA"),
    output_file = here::here(folder, paste0('report_qa-', 
                                            format(Sys.Date(),  '%d-%B-%Y'),  '.docx') ),
    params = list(activityInfoTable  = activityInfoTable,
                  year = year)  )
}

```
  
```{r example-report_qa} 
# ProgQA::report_qa(year = 2023, activityInfoTable= "cdn6y40lm87wi522",   folder = "dev/report")
```
  
```{r tests-report_qa}
test_that("report_qa works", {
  expect_true(inherits(report_qa, "function")) 
})
```
  

# report_qa_light
    
```{r function-report_qa_light}
# usethis::use_rmarkdown_template(
#   template_name = "report_qa_light",
#   template_dir = NULL,
#   template_description = "Report Quality Assurance Light",
#   template_create_dir = TRUE
# )
#' Generate a summary word report
#' 
#' @param activityInfo activityInfo link to the db
#' @param folder folder within your project where to put the generated report. 
#'              Folder will be created if it does not exist
#' 
#' @importFrom unhcrdown pptx_slides
#' @importFrom dplyr filter select pull
#' @importFrom rmarkdown render
#' @importFrom here here
#' @importFrom countrycode countrycode
#' @importFrom stringr str_replace_all
#' 
#' @return nothing the file for the report is generated
#' 
#' @export 
#'
report_qa_light <- function(year = 2023, 
                      activityInfoTable,
                      folder = "Report") {
  
  ## Create the outfolder if it does not exist
  output_dir <- paste0(getwd(),"/",folder)
  if (!dir.exists(output_dir)) {dir.create(output_dir)}
  
  rmarkdown::render(
    system.file("rmarkdown/templates/report_qa_light/skeleton/skeleton.Rmd", 
                package = "ProgQA"),
    output_file = here::here(folder, paste0('report_qa_light-', 
                                            format(Sys.Date(),  '%d-%B-%Y'),  '.docx') ),
    params = list(activityInfoTable  = activityInfoTable,
                  year = year)  )
}

```
  
```{r example-report_qa_light}
# ProgQA::report_qa_light(year = 2023, activityInfoTable= "cdn6y40lm87wi522",   folder = "dev/report")
```
  
```{r tests-report_qa_light}
test_that("report_qa_light works", {
  expect_true(inherits(report_qa_light, "function")) 
})
```
  

<!--
 below is a default chunk to create and document your run_app function
-->




<!--
 Once you have created your back office functions , run the next chunk to install and package them

# There can be development actions

Create a chunk with 'development' actions

- The chunk needs to be named `development` or `dev`
- It contains functions that are used for package development only
- Note that you may want to store most of these functions in the 0-dev_history.Rmd file

These are only included in the present flat template file, their content will not be part of the package anywhere else.
-->

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/function_documentation.Rmd", vignette_name = "Development")
```

